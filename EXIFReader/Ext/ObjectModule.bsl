///////////////////////////////////////////////////////
// Copyright: Ridvan Shikzatov (rivansmail@gmail.com) aka cashir101
// Created: 05.01.2019
// Licensed under Apache 2.0
///////////////////////////////////////////////////////

Перем Поток;
Перем ТекПорядокБайтов;
Перем Буф;
Перем БазовоеСмещение;

// Инициализируемые программные перечисления
Перем РазрешенныеСимволы;
Перем Сигнатуры;
Перем Форматы;
Перем ЧанкиPNG;
Перем ЕдиницыИзмеренияРазрешенияAPP0;
Перем СвойстваТиповEXIF;
Перем ТипыЗначенийEXIF;
Перем КаталогиТегов;

Перем Свойства Экспорт;
Перем СвойстваТаблица Экспорт;
Перем Логировать Экспорт;
Перем Лог Экспорт;
Перем Инициализирован Экспорт;

#Область Программные_перечисления

Функция РазрешенныеСимволы()

	РС =
	"ABCDEFGHIJKLMNOPQRSTUVWXYZ
	|abcdefghijklmnopqrstuvwxyz
	|АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЬЫЭЮЯ
	|абвгдеёзжийклмнопрстуфхцчшщъьыэюя
	|1234567890
	|,.!""№;%:?*()~@#$^&[]{}\/|'-+` "+Chars.NBSp;
	Возврат РС;

КонецФункции

Функция ПрочитатьИзМакетаТабДокумента(Макет, Тип="Структура")

	Если Тип = "Структура" Тогда
		Коллекция = Новый Структура;
	Иначе
		Коллекция = Новый Соответствие;
	КонецЕсли;

	Попытка
		Для Сч = 2 По Макет.ВысотаТаблицы Цикл
			ПерваяКолонка = Макет.Область( СтрШаблон("R%1C1", Сч) );
			ВтораяКолонка = Макет.Область( СтрШаблон("R%1C2", Сч) );
			Если НЕ ПустаяСтрока(ПерваяКолонка.Текст) И НЕ ПустаяСтрока(ВтораяКолонка.Текст) Тогда
				Коллекция.Вставить(ПерваяКолонка.Текст, ВтораяКолонка.Текст);
			КонецЕсли;
		КонецЦикла;
	Исключение
		ВызватьИсключение "неверный формат макета сигнатур";
	КонецПопытки;

	Возврат Коллекция;

КонецФункции

Функция Сигнатуры()

	МакетСигнатур = ЭтотОбъект.ПолучитьМакет("Сигнатуры");
	ИдентификаторыСигнатур = ПрочитатьИзМакетаТабДокумента(МакетСигнатур);
	ИдентификаторыСигнатур = Новый ФиксированнаяСтруктура(ИдентификаторыСигнатур);

	Возврат ИдентификаторыСигнатур;

КонецФункции

Функция Форматы()

	МакетФорматов = ЭтотОбъект.ПолучитьМакет("Форматы");
	ИдентификаторыФорматов = ПрочитатьИзМакетаТабДокумента(МакетФорматов);
	ИдентификаторыФорматов = Новый ФиксированнаяСтруктура(ИдентификаторыФорматов);

	Возврат ИдентификаторыФорматов;

КонецФункции

Функция ЧанкиPNG()

	КП = Новый Структура;

	КП.Вставить("IHDR", "IHDR");
	КП.Вставить("IDAT", "IDAT");
	КП.Вставить("PLTE", "PLTE");
	КП.Вставить("IEND", "IEND");

	Ф = Новый ФиксированнаяСтруктура(КП);

	Возврат Ф;

КонецФункции

Функция JPEG_OrdinaryTags()

	МакетТегов = ЭтотОбъект.ПолучитьМакет("JPEG_OrdinaryTags");
	СоответствиеХексТегам = ПрочитатьИзМакетаТабДокумента(МакетТегов, "Соответствие");
	СоответствиеХексТегам = Новый ФиксированноеСоответствие(СоответствиеХексТегам);

	Возврат СоответствиеХексТегам;

КонецФункции

Функция JPEG_GPSTags()

	МакетТегов = ЭтотОбъект.ПолучитьМакет("JPEG_GPSTags");
	СоответствиеХексТегам = ПрочитатьИзМакетаТабДокумента(МакетТегов, "Соответствие");
	СоответствиеХексТегам = Новый ФиксированноеСоответствие(СоответствиеХексТегам);

	Возврат СоответствиеХексТегам;

EndFunction

Функция КаталогиТегов()

	К = Новый Соответствие;

	К.Вставить("", JPEG_OrdinaryTags());
	К.Вставить(Сигнатуры.GPSInfoPointer, JPEG_GPSTags());
	К.Вставить(Сигнатуры.EXIFInfoPointer, К[""]);

	// Каталоги тегов перечисленные ниже - в текущей версии не поддерживаются.
	//К.Вставить(Сигнатуры.MakerTagsNotePointer, Новый Соответствие);
	//К.Вставить(Сигнатуры.PrivateDataPointer, Новый Соответствие);

	Ф = Новый ФиксированноеСоответствие(К);

	Возврат Ф;

КонецФункции

Функция ТипыЗначенийEXIF()

	КП = Новый Структура;

	КП.Вставить("Proprietary", "X");
	КП.Вставить("Byte", "B");
	КП.Вставить("ASCII", "A");
	КП.Вставить("Short", "S");
	КП.Вставить("Long", "L");
	КП.Вставить("Ratio", "R");

	КП.Вставить("SignedByte", "SB");

	КП.Вставить("Undefined", "U");

	КП.Вставить("SignedShort", "SS");
	КП.Вставить("SignedLong", "SL");
	КП.Вставить("SignedRatio", "SR");

	Ф = Новый ФиксированнаяСтруктура(КП);

	Возврат КП;

КонецФункции

Функция СвойстваТиповEXIF()

	СвойстваТипов = New Map;

	СвойстваТипов.Вставить(0,  НовыйСвойствоТипаEXIF(	0, 		"X",  	"Proprietary", 		FALSE, 	Undefined));
	СвойстваТипов.Вставить(1,  НовыйСвойствоТипаEXIF(	1, 		"B",  	"Byte", 			FALSE, 	TRUE));
	СвойстваТипов.Вставить(2,  НовыйСвойствоТипаEXIF(	1, 		"A",  	"ASCII", 			TRUE, 	TRUE));
	СвойстваТипов.Вставить(3,  НовыйСвойствоТипаEXIF(	2, 		"S",  	"Short", 			TRUE, 	TRUE));
	СвойстваТипов.Вставить(4,  НовыйСвойствоТипаEXIF(	4, 		"L",  	"Long", 			TRUE, 	TRUE));
	СвойстваТипов.Вставить(5,  НовыйСвойствоТипаEXIF(	8, 		"R",  	"Ratio", 			TRUE, 	TRUE));
	СвойстваТипов.Вставить(6,  НовыйСвойствоТипаEXIF(	1, 		"SB", 	"Signed Byte", 		TRUE, 	FALSE));
	СвойстваТипов.Вставить(7,  НовыйСвойствоТипаEXIF(	1, 		"U",  	"Undefined", 		FALSE, 	Undefined));
	СвойстваТипов.Вставить(8,  НовыйСвойствоТипаEXIF(	2, 		"SS", 	"Signed Short", 	TRUE, 	FALSE));
	СвойстваТипов.Вставить(9,  НовыйСвойствоТипаEXIF(	4, 		"SL", 	"Signed Long", 		TRUE, 	FALSE));
	СвойстваТипов.Вставить(10, НовыйСвойствоТипаEXIF(	8, 		"SR", 	"Signed Ratio", 	TRUE, 	FALSE));

	Return СвойстваТипов;

КонецФункции

Функция НовыйСвойствоТипаEXIF(Размер, Имя, ПолноеИмя, ЭтоЧисло, Беззнаковое)

	Стр = Новый Структура("Размер, Имя, ПолноеИмя, ЭтоЧисло, Беззнаковое", Размер, Имя, ПолноеИмя, ЭтоЧисло, Беззнаковое);
	ФСтр = Новый ФиксированнаяСтруктура(Стр);

	Возврат ФСтр;

КонецФункции

Функция ЕдиницыИзмеренияРазрешенияAPP0()

	С = Новый Соответствие;

	С.Вставить(0, "-");
	С.Вставить(1, "dpi");
	С.Вставить(2, "dpcm");

	Возврат С;

КонецФункции

#КонецОбласти

Процедура ПрочитатьФайл(ПутьКФайлу) Экспорт

	СброситьВнутреннееСостояние();

	Файл = Новый Файл(ПутьКФайлу);
	Если НЕ Файл.ЭтоФайл() Тогда
		Лог("Путь %1 не указывает на файл");
		Возврат;
	КонецЕсли;

	НоваяСтрокаСвойства("Расширение", Файл.Расширение);

	Поток = ФайловыеПотоки.ОткрытьДляЧтения(ПутьКФайлу);
	ПрочитатьПоток(Поток);

КонецПроцедуры

Процедура ПрочитатьДвоичныеДанные(ДвоичныеДанные) Экспорт

	#Если НужнаКонтектстнаяпПодсказка Тогда
		ДвоичныеДанные = Новый ДвоичныеДанные;
	#КонецЕсли

	Поток = ДвоичныеДанные.ОткрытьПотокДляЧтения();
	ПрочитатьПоток(Поток);

КонецПроцедуры

Процедура ПрочитатьПоток(ИспользуемыйПоток) Экспорт

	Если Инициализирован <> Истина Тогда
		Инициализировать();
	КонецЕсли;

	Поток = ИспользуемыйПоток;

	#Если НужнаКонтектстнаяпПодсказка Тогда
		Поток = Новый ПотокВПамяти;
	#КонецЕсли

	Попытка

		Если НЕ Поток.ДоступноЧтение Тогда
			Лог("Невозможно прочитать из потока");
			Поток.Закрыть();
			Возврат;
		КонецЕсли;

		Если НЕ Поток.ДоступноИзменениеПозиции Тогда
			Лог("Невозможно перемещение по потоку");
			Поток.Закрыть();
			Возврат
		КонецЕсли;

		НоваяСтрокаСвойства("Размер", Поток.Размер());

		// Сценарии работы с разными файлами существенной различаются,
		//поэтому сигнатуру файла необходимо прочитать независимо от остальных свойств файла.
		ПрочитатьСигнатуруФайла();

		Если Свойства.Свойство("ЭтоКартинка") И Свойства.ЭтоКартинка = Истина Тогда
			ПрочитатьСвойстваКартинки();
		КонецЕсли;

		Поток.Закрыть();

	Исключение

		Поток.Закрыть();
		ВызватьИсключение;

	КонецПопытки;

КонецПроцедуры

Функция Сводка() Экспорт

	Возврат ПолучитьСводку(Свойства);

КонецФункции

#Область Общие_вспомогательные_процедуры_и_функции

Функция ПолучитьСводку(ПарыКлючЗначение, УровеньВложенности=0)

	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, ПарыКлючЗначение, НазначениеТипаXML.Неявное);

	Рез = ЗаписьJSON.Закрыть();
	Возврат Рез;

КонецФункции

Функция Из16(Стр16)

	Возврат ЧислоИзШестнадцатеричнойСтроки(СтрШаблон("0x%1", Стр16));

КонецФункции

Функция Байты16(БайтыСтрокой16, От=0, КоличествоБайтов=1)

	Возврат Сред(БайтыСтрокой16, От*2+1, КоличествоБайтов*2); // 2 это число hex символов в байте

КонецФункции

Функция ПрочитатьБайты(КоличествоБайтов=1, Строкой=Истина)

	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	Поток.Прочитать(Буф, 0, КоличествоБайтов);

	Значение = Буф.ПолучитьСрез(0, КоличествоБайтов);

	Если ТекПорядокБайтов = ПорядокБайтов.LittleEndian Тогда
		Значение = Значение.Перевернуть();
	КонецЕсли;

	Если Строкой Тогда
		Значение = ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Значение);
	Иначе
		Значение = Значение;
	КонецЕсли;

	Возврат Значение;

КонецФункции

Функция ПрочитатьЧисло(КоличествоБайтов=2)

	Буфер = ПрочитатьБайты(КоличествоБайтов, Ложь);

	#Если Автозаполнение Тогда
		Буфер = Новый БуферДвоичныхДанных;
	#КонецЕсли

	Если КоличествоБайтов = 2 Тогда
		// ПорядокБайтов.BigEndian потому что в Буфере уже байты в нужном порядке
		Число = Буфер.ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);
	ИначеЕсли КоличествоБайтов = 4 Тогда
		Число = Буфер.ПрочитатьЦелое32(0, ПорядокБайтов.BigEndian);
	ИначеЕсли КоличествоБайтов = 8 Тогда
		Число = Буфер.ПрочитатьЦелое64(0, ПорядокБайтов.BigEndian);
	Иначе
		ВызватьИсключение "Неверная разрядность числа";
	КонецЕсли;

	Возврат Число;

КонецФункции

Функция ПрочитатьСтроку(КоличествоБайтов=2)

	Буфер = ПрочитатьБайты(КоличествоБайтов, Ложь);

	#Если Автозаполнение Тогда
		Буфер = Новый БуферДвоичныхДанных;
	#КонецЕсли

	// Возвращаем порядок байтов, потому что это не работает для строк
	Если ТекПорядокБайтов = ПорядокБайтов.LittleEndian Тогда
		Буфер = Буфер.Перевернуть();
	КонецЕсли;

	Строка = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буфер);

	Возврат Строка;

КонецФункции

Функция Идти(КоличествоБайтов)
	Поток.Перейти(КоличествоБайтов, ПозицияВПотоке.Текущая);
КонецФункции

Функция ИдтиВ(КоличествоБайтов)
	Поток.Перейти(КоличествоБайтов, ПозицияВПотоке.Начало);
КонецФункции

Процедура Лог(ЗНАЧ Строка, Параметр1=Неопределено, Параметр2=Неопределено, Параметр3=Неопределено)

	Если Логировать = Истина Тогда

		Если Параметр3<>Неопределено Тогда
			Строка = СтрШаблон(Строка, Параметр1, Параметр2, Параметр3);
		ИначеЕсли Параметр2<>Неопределено Тогда
			Строка = СтрШаблон(Строка, Параметр1, Параметр2);
		ИначеЕсли Параметр1<>Неопределено Тогда
			Строка = СтрШаблон(Строка, Параметр1);
		КонецЕсли;

		Лог = Лог + Строка + Символы.ПС;

	КонецЕсли;

КонецПроцедуры

Функция Порядок(Байты)

	Порядок = Неопределено;

	Если НРег(Байты) = Сигнатуры.LittleEndian Тогда  // "4949"
		Порядок = ПорядокБайтов.LittleEndian;
	ИначеЕсли НРег(Байты) = Сигнатуры.BigEndian Тогда  // "4b4b"
		Порядок = ПорядокБайтов.BigEndian;
	КонецЕсли;

	Возврат Порядок;

КонецФункции

Функция НовыйЗначениеТега(Значение, Представление, Тег)

	С = Новый Структура("Значение, Представление, Элемент", Значение, Представление, Тег);
	Возврат Новый ФиксированнаяСтруктура(С);

КонецФункции

Процедура СброситьВнутреннееСостояние()

	#Если Автозаполнение Тогда
		Поток = Новый ПотокВПамяти;
	#КонецЕсли

	#Если Автозаполнение Тогда
		Буф = Новый БуферДвоичныхДанных;
	#КонецЕсли

	ТекПорядокБайтов = Неопределено;
	БазовоеСмещение = Неопределено;

	Свойства = Новый Структура;
	СвойстваТаблица = Новый ТаблицаЗначений;
	СвойстваТаблица.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	СвойстваТаблица.Колонки.Добавить("Значение", Новый ОписаниеТипов("Строка"));
	СвойстваТаблица.Колонки.Добавить("Код", Новый ОписаниеТипов("Строка"));

	СвойстваТаблица.Индексы.Добавить("Код");

КонецПроцедуры

Функция Инициализировать()

	ТекПорядокБайтов = Неопределено;
	Свойства = Новый Структура;
	Логировать = Ложь;
	Лог = "";
	ОбъёмБуфера = 4096;  // Просто с запасом, подобрано эмпирически
	Буф = Новый БуферДвоичныхДанных(ОбъёмБуфера);
	Сигнатуры = Сигнатуры();
	Форматы = Форматы();
	ЧанкиPNG = ЧанкиPNG();
	ЕдиницыИзмеренияРазрешенияAPP0 = ЕдиницыИзмеренияРазрешенияAPP0();
	СвойстваТиповEXIF = СвойстваТиповEXIF();
	ТипыЗначенийEXIF = ТипыЗначенийEXIF();
	КаталогиТегов = КаталогиТегов();
	РазрешенныеСимволы = РазрешенныеСимволы();

	СброситьВнутреннееСостояние();

	Инициализирован = Истина;

КонецФункции

Процедура НоваяСтрокаСвойства(Наименование, Значение, Код="")

	СтрокаСвойств = СвойстваТаблица.Добавить();
	СтрокаСвойств.Наименование = Наименование;
	СтрокаСвойств.Значение = Значение;
	СтрокаСвойств.Код = Код;

	Свойства.Вставить(Наименование, Значение)

КонецПроцедуры

#КонецОбласти

Процедура ПрочитатьСигнатуруФайла()

	#Если НужнаКонтектстнаяпПодсказка Тогда
		Поток = Новый ПотокВПамяти;
	#КонецЕсли

	ИсходнаяПозиция = Поток.ТекущаяПозиция();
	ДостаточноеКоличествоБайт = 15;  // Определено разработчиком

	Поток.Прочитать(Буф, 0, ДостаточноеКоличествоБайт);
	СтрокаСигнатуры = НРег(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буф));

	Если ЭтоJPG(СтрокаСигнатуры) Тогда

		НоваяСтрокаСвойства("Формат", Форматы.JPG);
		НоваяСтрокаСвойства("ЭтоКартинка", Истина);
	// ИначеЕсли ... другие форматы
	Иначе

		// Здесь могут быть форматы, сигнатура которых записана с ненулевым смещением, по сложному алгоритму или файлы сводимые к простому текстовому формату
		НоваяСтрокаСвойства("Формат", Форматы.Неизвестно);

	КонецЕсли;

	Поток.Перейти(ИсходнаяПозиция, ПозицияВПотоке.Начало);

КонецПроцедуры

Процедура ПрочитатьСвойстваКартинки()

	#Если НужнаКонтектстнаяпПодсказка Тогда
		Поток = Новый ПотокВПамяти;
	#КонецЕсли

	НачальнаяПозиция = Поток.ТекущаяПозиция();
	Если Не НачальнаяПозиция = 0 Тогда
		Поток.Перейти(0, ПозицияВПотоке.Начало);
	КонецЕсли;

	Если Свойства.Формат = Форматы.JPG Тогда
		ПрочитатьИВалидироватьСвойстваJPG();
	КонецЕсли;

	Если Поток.ТекущаяПозиция() <> НачальнаяПозиция Тогда
		Поток.Перейти(НачальнаяПозиция, ПозицияВПотоке.Начало);
	КонецЕсли;

КонецПроцедуры

#Область Валидация_cигнатуры

Функция ЭтоPNG(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураPNG) = 1;
КонецФункции

Функция ЭтоJPG(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураJPG) = 1;
КонецФункции

Функция ЭтоBMP(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураBMP) = 1;
КонецФункции

Функция ЭтоGIF87(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураGIF87) = 1;
КонецФункции

Функция ЭтоGIF89(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураGIF89) = 1;
КонецФункции

Функция ЭтоTIFFL(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураTIFFL) = 1;
КонецФункции

Функция ЭтоTIFFB(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураTIFFB) = 1;
КонецФункции

Функция ЭтоZIP(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураZIP) = 1;
КонецФункции

Функция ЭтоZIP_E(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураZIP_E) = 1;
КонецФункции

Функция ЭтоZIP_S(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураZIP_S) = 1;
КонецФункции

Функция ЭтоRAR15(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRAR15) = 1;
КонецФункции

Функция ЭтоRAR50(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRAR50) = 1;
КонецФункции

Функция ЭтоPDF(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураPDF) = 1;
КонецФункции

Функция ЭтоOGG(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураOGG) = 1;
КонецФункции

Функция ЭтоRIFF_WAVE(СтрокаHexСигнатуры)

	_1 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRIFF) = 1;
	_2 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRIFF_WAVE, НаправлениеПоиска.СНачала, 9) = 9;

	Возврат _1 И _2;

КонецФункции

Функция ЭтоRIFF_AVI(СтрокаHexСигнатуры)

	_1 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRIFF) = 1;
	_2 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRIFF_AVI, НаправлениеПоиска.СНачала, 9) = 9;

	Возврат _1 И _2;

КонецФункции

Функция ЭтоMP3_NOID3(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураMP3_NOID3) = 1;
КонецФункции

Функция ЭтоMP3_ID3(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураMP3_ID3) = 1;
КонецФункции

Функция ЭтоFLAC(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураFLAC) = 1;
КонецФункции

Функция ЭтоMSDOC(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураMSDOC) = 1;
КонецФункции

Функция Это7ZIP(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.Сигнатура7ZIP) = 1;
КонецФункции

Функция ЭтоGZ(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.Сигнатура7ZIP) = 1;
КонецФункции

Функция ЭтоMKV(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураMKV) = 1;
КонецФункции

Функция ЭтоDJVU(СтрокаHexСигнатуры)

	_1 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураDJVU_1) = 1;
	_2 = СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураDJVU_1, НаправлениеПоиска.СНачала, 13) = 13;

	Возврат _1 И _2;

КонецФункции

Функция ЭтоRTF(СтрокаHexСигнатуры)
	Возврат СтрНайти(СтрокаHexСигнатуры, Сигнатуры.СигнатураRTF) = 1;
КонецФункции

#КонецОбласти

#Область JPEG

Процедура ПрочитатьИВалидироватьСвойстваJPG()

	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	ПозицияПервогоРаздела = СтрДлина(Сигнатуры.СигнатураJPG)/2; // делим на два потому что два символа в байте
	Поток.Перейти(ПозицияПервогоРаздела, ПозицияВПотоке.Начало);

	Разделы = Новый Соответствие;

	// Прочитать позиции всех известных разделов, начинающиеся с FF
	Поток.Прочитать(Буф, 0, 4);  // прочитаем раздел и размер раздела

	Байты = НРег(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буф.ПолучитьСрез(0, 2)));
	Размер = Буф.ПолучитьСрез(2, 2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	Пока Лев(Байты, 2) = Сигнатуры.ПрефиксТега И Размер > 0 Цикл

		Поз = Поток.ТекущаяПозиция();
		Разделы.Вставить(Поз-4, Байты); // т.к. размер секции 2 байта + имя секции еще 2 байта уже прочитаны

		Поток.Перейти(Размер-2, ПозицияВПотоке.Текущая); // размер указывается с учетом байтов размера секции

		Поток.Прочитать(Буф, 0, 4);
		Байты = НРег(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буф.ПолучитьСрез(0, 2)));

		Если Байты = Сигнатуры.SOS Тогда
			Прервать;  // Дальше не дожно быть значимых тегов
		КонецЕсли;

		Размер = Буф.ПолучитьСрез(2, 2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	КонецЦикла;

	// Для известных разделов вызвать читатель этого раздела
	Для каждого Пара Из Разделы Цикл

		Если Пара.Значение = Сигнатуры.APP0 Тогда
			Прочитать_APP0(Пара.Ключ);
		ИначеЕсли Пара.Значение = Сигнатуры.APP1 Тогда
			Прочитать_APP1(Пара.Ключ);
		ИначеЕсли Пара.Значение = Сигнатуры.SOF0 Тогда
			Прочитать_SOF0(Пара.Ключ);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Процедура Прочитать_APP0(ПозицияРаздела)

	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	НачальнаяПозиция = Поток.ТекущаяПозиция();

	Поток.Перейти(ПозицияРаздела+2, ПозицияВПотоке.Начало);

	Поток.Прочитать(Буф, 0, 2);
	Длина = Буф.ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	Если Длина < 16 Тогда
		Лог("Некорректный формат файла JPEG: Ошибка чтения секции APP0")
	КонецЕсли;

	ДостаточноеКоличествоБайт = 12; // потому что после 12 байта в сегменте записаны неинтересные данные
	Поток.Прочитать(Буф, 0, ДостаточноеКоличествоБайт);
	
	// Далее в буфер прочитаны данные жесткой структуры, считаем что при разборе такого сегмента магические числа оправданы.

	JFIF0 = НРег(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буф.ПолучитьСрез(0, 5)));

	Если JFIF0 <> Сигнатуры.JFIF0 Тогда
		Лог("Некорректный формат файла JPEG: Ошибка чтения секции APP0");
		Возврат;
	КонецЕсли;

	Версия = Буф.ПолучитьСрез(5,1).Получить(0);

	Если Версия <> 1 Тогда
		Лог("Некорректный формат файла JPEG: Непредвиденная версия (%1.Х) формата секции APP0", Версия);
		Возврат;
	КонецЕсли;

	Подверсия = Буф.ПолучитьСрез(6,1).Получить(0);
	Если Подверсия > 2 Тогда
		Лог("Некорректный формат файла JPEG: Непредвиденная версия (%1.%2) формата секции APP0", Версия, Подверсия);
		Возврат;
	КонецЕсли;

	ЕдиницаИзмеренияРазрешения = Буф.ПолучитьСрез(7,1).Получить(0);
	ПредставлениеЕдиницыИзмеренияРазрешения = ЕдиницыИзмеренияРазрешенияAPP0[ЕдиницаИзмеренияРазрешения];

	РазрешениеX = Буф.ПолучитьСрез(8,2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);
	РазрешениеY = Буф.ПолучитьСрез(10,2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	НоваяСтрокаСвойства("ВерсияJFIF", СтрШаблон("%1.%2", Версия, Подверсия));
	НоваяСтрокаСвойства("РазрешениеJFIF", СтрШаблон("%1x%2 %3", РазрешениеX, РазрешениеY, ПредставлениеЕдиницыИзмеренияРазрешения));

	Поток.Перейти(НачальнаяПозиция, ПозицияВПотоке.Начало);

КонецПроцедуры

Процедура Прочитать_APP1(ПозицияРаздела)

	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	НачальнаяПозиция = Поток.ТекущаяПозиция();

	ИдтиВ(ПозицияРаздела+2);
	Длина = ПрочитатьЧисло(2);
	Сигнатура = ПрочитатьБайты(4);

	Если Сигнатура = Сигнатуры.EXIF Тогда

		_0000 = ПрочитатьБайты(2);
		Если _0000 = Сигнатуры.ZEROS Тогда
			БазовоеСмещение = Поток.ТекущаяПозиция();  // точка отсчета секции EXIF
		Иначе
			Лог("Некорректный формат файла JPEG: Ошибка структуры EXIF");
			Возврат;
		КонецЕсли;

		ПБ = ПрочитатьБайты(2);
		ТекПорядокБайтов = Порядок(ПБ);
		_42 = ПрочитатьЧисло(2);
		Смещение = ПрочитатьЧисло(4);  // точка отсчета позиции каталога от секции EXIF

		// Разные производители камер могут по разному определять точку отсчета секции EXIF.
		// По стандарту это позиция от байтов кодирующих порядок байтов.
		// Возможно для других производителей камер потребуется переопределить здесь переменную Смещение.
		ПрочитатьКаталогEXIF(Смещение+БазовоеСмещение);

	ИначеЕсли Сигнатура = Сигнатуры.HTTP Тогда

	КонецЕсли;

	Поток.Перейти(НачальнаяПозиция, ПозицияВПотоке.Начало);

КонецПроцедуры

Процедура Прочитать_SOF0(ПозицияРаздела)

	// Далее читаем только полезные свойства.
	// Часть свойств пропускаем в целях улучшения производительности и из-за отсутствия практической пользы на текущий момент.
	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	НачальнаяПозиция = Поток.ТекущаяПозиция();
	Поток.Перейти(ПозицияРаздела+2, ПозицияВПотоке.Начало);

	Поток.Прочитать(Буф, 0, 2);
	Длина = Буф.ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	ДостаточноеКоличествоБайт = 5; // потому что после 5 байта в сегменте записаны неинтересные данные
	Поток.Прочитать(Буф, 0, ДостаточноеКоличествоБайт);
	// Далее в буфер прочитаны данные жесткой структуры, считаем что при разборе такого сегмента магические числа оправданы.

	// Precision = Буф.Получить(0);
	Высота = Буф.ПолучитьСрез(1, 2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);
	Ширина = Буф.ПолучитьСрез(3, 2).ПрочитатьЦелое16(0, ПорядокБайтов.BigEndian);

	НоваяСтрокаСвойства("ВысотаКадра", Высота);
	НоваяСтрокаСвойства("ШиринаКадра", Ширина);

	Поток.Перейти(НачальнаяПозиция, ПозицияВПотоке.Начало);

КонецПроцедуры

Процедура ПрочитатьКаталогEXIF(ПозицияКаталога, РодительскийКаталог=Неопределено)

	НачальнаяПозиция = Поток.ТекущаяПозиция();

	ИдтиВ(ПозицияКаталога);
	КоличествоЗаписейВКаталоге = ПрочитатьЧисло(2);

	Д = 12;  // Длина одной записи в байтах

	Для Сч = 1 По КоличествоЗаписейВКаталоге Цикл

		Тег = ПрочитатьБайты(2);
		Тип = ПрочитатьЧисло(2);
		Количество = ПрочитатьЧисло(4);

		ОписаниеТипа = ТипEXIF(Тип);
		ОписаниеТега = ОписаниеТега(Тег, РодительскийКаталог);

		ПределЗначения = 4; // 4 байта на запись. Если значение не укладывается в 4 байта то в записи указывается смещение от байтов порядка в котором можно прочитать значение
		Если ОписаниеТипа.Размер * Количество > ПределЗначения Тогда

			Смещение = ПрочитатьЧисло(4);

			НачалоСледующегоЭлементаКаталога = Поток.ТекущаяПозиция();
			ИдтиВ(БазовоеСмещение+Смещение);
			ЗначениеТега = ЗначениеТега(ОписаниеТипа, Количество, Тег);

			НоваяСтрокаСвойства(ОписаниеТега, ЗначениеТега.Представление, Тег);

			ИдтиВ(НачалоСледующегоЭлементаКаталога);

		Иначе

			ЭтоПодкаталог = (КаталогиТегов.Получить(Тег) <> Неопределено);
			Если ЭтоПодкаталог Тогда
				Смещение = ПрочитатьЧисло(4);
				ПрочитатьКаталогEXIF(БазовоеСмещение+Смещение, Тег);
			Иначе
				ЗначениеТега = ЗначениеТега(ОписаниеТипа, Количество, Тег);

				НоваяСтрокаСвойства(ОписаниеТега, ЗначениеТега.Представление, Тег);

				Выравнивание = ПределЗначения-ОписаниеТипа.Размер*Количество;
				Если Выравнивание > 0 Тогда
					Идти(Выравнивание);
				КонецЕсли;
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	СмещениеДоСледующегоКаталога = ПрочитатьЧисло(4);
	Лог("СмещениеДоСледующегоКаталога = %1", СмещениеДоСледующегоКаталога);

	ИдтиВ(НачальнаяПозиция);

КонецПроцедуры

Функция ТипEXIF(КодТипа)

	СвойстваТипа = СвойстваТиповEXIF[КодТипа];
	Если СвойстваТипа = Неопределено Тогда
		СвойстваТипа = СвойстваТиповEXIF[0]
	КонецЕсли;

	Возврат СвойстваТипа;

КонецФункции

Функция ОписаниеТега(ЗНАЧ Hex, ЗНАЧ РодительскийКаталог=Неопределено)

	// В соответствии не получится использовать ключ со значением неопределено, поэтому переопределим значение каталога
	Если РодительскийКаталог = Неопределено Тогда
		РодительскийКаталог = ""; 
	КонецЕсли;
	ОписаниеРодительскогоКаталога = КаталогиТегов[""].Получить(РодительскийКаталог);

	КаталогТегов = КаталогиТегов.Получить(РодительскийКаталог);

	Если КаталогТегов = Неопределено Тогда
		КаталогТегов = КаталогиТегов[""];
	КонецЕсли;

	ОписаниеТега = КаталогТегов.Получить(Hex);

	Если ОписаниеТега = Неопределено Тогда
		Описание = СтрШаблон("%1Tag%2", ?(РодительскийКаталог="", "", СтрШаблон("%1_", ОписаниеРодительскогоКаталога)), Hex);
	Иначе
		Описание = СтрШаблон("%1%2", ?(РодительскийКаталог="", "", СтрШаблон("%1_", ОписаниеРодительскогоКаталога)), ОписаниеТега);
	КонецЕсли;

	Возврат Описание;

КонецФункции

Функция ЗначениеТега(ОписаниеТипа, КоличествоЗначений, Тег)

	#Если Автозаполнение Тогда
		Поток = ФайловыеПотоки.ОткрытьДляЧтения(Path);
	#КонецЕсли

	ОбъемДанных = КоличествоЗначений*ОписаниеТипа.Размер;

	Если ОписаниеТипа.Имя = ТипыЗначенийEXIF.ASCII Тогда
		Поток.Прочитать(Буф, 0, ОбъемДанных);
		Значение = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буф.ПолучитьСрез(0, ОбъемДанных));
		Представление = ?(СтрДлина(Значение)>50, СтрШаблон("%1...", Лев(Значение, 45)), Значение);
		Представление = ОчиститьСтроку(Представление);
	Иначе

		Если ОписаниеТипа.ЭтоЧисло Тогда

			МассивЗначений = Новый Массив;
			МассивПредставлений = Новый Массив;
			Для Сч = 1 По КоличествоЗначений Цикл

				Если НЕ ОписаниеТипа.Беззнаковое Тогда
					ДиапазонТипа = СтрШаблон("0x%1", Лев("FFFFFFFF", ОписаниеТипа.Размер));
					Поправка = BitwiseShiftRight(NumberFromHexString(ДиапазонТипа), 1);
				Иначе
					Поправка = 0;
				КонецЕсли;

				Если ОписаниеТипа.Размер = 8 Тогда // это рациональное число - особый случай
					Число = ПрочитатьЧисло(4)-Поправка;
					Делитель = ПрочитатьЧисло(4)-Поправка;
					Представление = СтрШаблон("%1/%2", Число, Делитель);
				Иначе
					Число = ПрочитатьЧисло(ОписаниеТипа.Размер)-Поправка;
					Представление = Формат(Число, "ЧН=0; ЧГ=0");
				КонецЕсли;

				МассивЗначений.Добавить(Число);
				МассивПредставлений.Добавить(Представление);

			КонецЦикла;
			Значение = МассивЗначений;
			Представление = СтрСоединить(МассивПредставлений, ", ");

		Иначе
			Значение = Неопределено;
			Представление = "не прочитано";
			Поток.Перейти(ОбъемДанных, ПозицияВПотоке.Текущая);
		КонецЕсли;

	КонецЕсли;

	ЗначениеТега = НовыйЗначениеТега(Значение, Представление, Тег);

	Возврат ЗначениеТега;

КонецФункции

Функция ОчиститьСтроку(ЗНАЧ Строка)

	Строка = СтрСоединить(СтрРазделить(Строка, СтрСоединить(СтрРазделить(Строка, РазрешенныеСимволы))));

	Return Строка;

КонецФункции

#КонецОбласти

#Область BMP

Процедура ПрочитатьИВалидироватьСвойстваBMP()

	РазмерЗаголовка = 54; // Далее будем их читать
	РазмерПотока = Поток.Размер();

	Если РазмерПотока < РазмерЗаголовка Тогда
		Лог("Возможно нарушена целостность файла BMP");
		Возврат;
	КонецЕсли;

	Сигнатура = ПрочитатьСтроку(2);
	Размер = ПрочитатьЧисло(4);
	_00 = ПрочитатьБайты(4);
	СмещениеДоКартинки = ПрочитатьЧисло(4);
	_40 = ПрочитатьЧисло(4);
	Ширина = ПрочитатьЧисло(4);
	Высота = ПрочитатьЧисло(4);
	_1 = ПрочитатьЧисло(2);
	БитНаПиксель = ПрочитатьЧисло(2); // 1, 4, 8 или 24
	ТипКомпрессии = ПрочитатьЧисло(4);
	РазмерИзображенияВБайтах = ПрочитатьЧисло(4);
	РазрешениеX = ПрочитатьЧисло(4);
	РазрешениеY = ПрочитатьЧисло(4);
	ЦветовВИзображении = ПрочитатьЧисло(4);
	ВажныхЦветовВИзображении = ПрочитатьЧисло(4);

	Если Сигнатура <> "BM" Тогда
		Лог("Непредвиденная сигнатура %1", Сигнатура);
		Возврат;
	КонецЕсли;

	Если Размер = 0 ИЛИ РазмерПотока < Размер Тогда
		Лог("Возможно нарушена целостность файла BMP");
		Возврат;
	КонецЕсли;

	Если _00 <> "00000000" Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если СмещениеДоКартинки = 0 ИЛИ СмещениеДоКартинки > Размер Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если _40 <> 40 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если Ширина = 0 Или Высота = 0 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если _1 <> 1 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если БитНаПиксель <> 24 И БитНаПиксель <> 8 И БитНаПиксель <> 4 И БитНаПиксель <> 1 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если ТипКомпрессии <> 0 И БитНаПиксель <> 1 И БитНаПиксель <> 2 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	Если РазмерИзображенияВБайтах = 0 Тогда
		Лог("Некорректный формат файла BMP");
		Возврат;
	КонецЕсли;

	НоваяСтрокаСвойства("Ширина", Высота);
	НоваяСтрокаСвойства("Высота", Ширина);
	НоваяСтрокаСвойства("Разрешение", СтрШаблон("%1x%2 %3", РазрешениеX, РазрешениеY, "dpi"));

КонецПроцедуры

#КонецОбласти

#Область PNG

Процедура ПрочитатьИВалидироватьСвойстваPNG()

	#Если НужнаКонтектстнаяпПодсказка Тогда
		Поток = Новый ПотокВПамяти;
	#КонецЕсли
	КоличествоБайтовСигнатуры = СтрДлина(Сигнатуры.СигнатураPNG)/2;  // задана строкой - два символа на байт, поэтому делим на два
	Идти(КоличествоБайтовСигнатуры);

	// Чанк кодируется так:
	// 4 байта {Длина} чанка + 4 байта имя чанка + {Длина} байтов соержание чанка + 4 байта CRC-контрольная сумма

	ТаймаутЧтение = 1000;
	Т = ТекущаяУниверсальнаяДатаВМиллисекундах();

	ТекущийПорядокЧанка = 0;
	Пока Истина Цикл

		// Перестраховка для бесконечного цикла
		Если ТекущаяУниверсальнаяДатаВМиллисекундах()-Т > ТаймаутЧтение Тогда
			Лог("Чтение файла PNG прервано по таймауту %1 мс", ТаймаутЧтение);
			Прервать;
		КонецЕсли;

		ДлинаЧанка = ПрочитатьЧисло(4);
		КоличествоБайтовЧанка = 4+ДлинаЧанка+4;
		Поток.Прочитать(Буф, 0, КоличествоБайтовЧанка);

		ИмяЧанка = ПолучитьСтрокуИзБуфераДвоичныхДанных(Буф.ПолучитьСрез(0, 4));

		ПервыйСимвол = Лев(ИмяЧанка, 1);
		Если ПервыйСимвол = ВРЕГ(ПервыйСимвол) Тогда

			СодержимоеСТипом = Буф.ПолучитьСрез(0, 4+ДлинаЧанка);

			CRC32 = Новый ХешированиеДанных(ХешФункция.CRC32);
			CRC32.Добавить(ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(СодержимоеСТипом));
			РасчетныйCRC = CRC32.ХешСумма;

			CRCЧанка = Буф.ПолучитьСрез(4+ДлинаЧанка, 4).ПрочитатьЦелое32(0, ПорядокБайтов.BigEndian);

			Если CRCЧанка <> РасчетныйCRC Тогда
				Лог("Некорректный формат файла PNG: invalid CRC");
				Прервать;
			КонецЕсли;

			// В текущей реализации из PNG файлов получаются только основные свойства заголовка: Ширина, Высота, Глубина и тип цвета в изображении
			Если ИмяЧанка = ЧанкиPNG.IHDR Тогда

				// Ширина(4), Высота(4), Глубина(1), Тип(1) - в сумме 10 байт
				Содержимое = Буф.ПолучитьСрез(4, 10);
				Ширина = Содержимое.ПолучитьСрез(0, 4).ПрочитатьЦелое32(0, ПорядокБайтов.BigEndian);
				Высота = Содержимое.ПолучитьСрез(4, 4).ПрочитатьЦелое32(0, ПорядокБайтов.BigEndian);
				Глубина = Содержимое.ПолучитьСрез(8, 1).Получить(0);
				ТипЦвета = Содержимое.ПолучитьСрез(9, 1).Получить(0);

				НоваяСтрокаСвойства("Ширина", Высота);
				НоваяСтрокаСвойства("Высота", Ширина);
				НоваяСтрокаСвойства("Прозрачный", ?(ТипЦвета=4 ИЛИ ТипЦвета=6, Истина, Ложь));

				Прервать;

			КонецЕсли;

		Иначе
			Лог("Пропущен некритичный %1", ИмяЧанка);
		КонецЕсли;

		ТекущийПорядокЧанка = ТекущийПорядокЧанка + 1;
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

Если Инициализирован <> Истина Тогда

	Инициализировать();

КонецЕсли;